
__global__ void s2g2drbwarp(coord *V, coord *y, coord *q, uint32_t *ib,
                            uint32_t *cb, uint32_t ng, uint32_t nPts,
                            uint32_t nDim, uint32_t nVec) {
  __shared__ coord partial_sum[4 * 4 * 3 * BlockSizeWarp2D];
  register uint32_t f1, f2;
  coord d;
  coord v1[4], v2[4];
  register uint32_t idx1, idx2;
  register uint32_t tid = blockIdx.x * blockDim.x + threadIdx.x;
  uint32_t lane = tid % 32;
  uint32_t warpid = (uint32_t)tid / 32;
  // for(uint32_t boxIdx=warpid; boxIdx<(ng-2)*(ng-2)-ng-2;boxIdx+= gridDim.x *
  // blockDim.x / 32){
  //for (uint32_t i = warpid; i < ng - 2; i += gridDim.x * blockDim.x / 32) {
    //for (uint32_t j = 0; j < ng - 2; j++) {
      for(int boxIdx=warpid;boxIdx<(ng-2)*(ng-2);boxIdx+= gridDim.x * blockDim.x / 32){
      //uint32_t boxIdx = i * (ng - 2) + j;
      if(boxIdx>=(ng-2)*(ng-3)-1  ){return;}

      for (int temp = 0; temp < 4 * 4 * 3; temp++) {
        partial_sum[temp * BlockSizeWarp2D + threadIdx.x] = 0;
      }
      for (uint32_t TID = threadIdx.x; TID < ib[boxIdx + 1] - ib[boxIdx];
           TID += warpsize) {
        f1 = (uint32_t)floor(y[ib[boxIdx] + TID]);
        d = y[ib[boxIdx] + TID] - (coord)f1;

        v1[0] = g2(1 + d);
        v1[1] = g1(d);
        v1[2] = g1(1 - d);
        v1[3] = g2(2 - d);

        f2 = (uint32_t)floor(y[ib[boxIdx] + TID + nPts]);
        d = y[ib[boxIdx] + TID + nPts] - (coord)f2;

        v2[0] = g2(1 + d);
        v2[1] = g1(d);
        v2[2] = g1(1 - d);
        v2[3] = g2(2 - d);
        for (uint32_t iVec = 0; iVec < nVec; iVec++) {
          for (idx2 = 0; idx2 < 4; idx2++) {
            coord qv = q[nPts * iVec + ib[boxIdx] + TID] * v2[idx2];
            for (idx1 = 0; idx1 < 4; idx1++) {
              partial_sum[(iVec * 4 * 4 + idx2 * 4 + idx1) * BlockSizeWarp2D +
                          threadIdx.x] += qv * v1[idx1];
            }
          }
        }
      }

      warpReduce2V2D(partial_sum, V, f1, f2, nVec, ng, lane);

  }
}

__global__ void s2g2drbwarp(coord *V, coord *y, coord *q, uint32_t *ib,
                            uint32_t *cb, uint32_t ng, uint32_t nPts,
                            uint32_t nDim, uint32_t nVec) {
  __shared__ coord partial_sum[4 * 4 * 3 * BlockSizeWarp2D];
  register uint32_t f1, f2;
  coord d;
  coord v1[4], v2[4];
  register uint32_t idx1, idx2;
  register uint32_t tid = blockIdx.x * blockDim.x + threadIdx.x;
  uint32_t lane = tid % 32;
  uint32_t warpid = (uint32_t)tid / 32;
  // for(uint32_t boxIdx=warpid; boxIdx<(ng-2)*(ng-2)-ng-2;boxIdx+= gridDim.x *
  // blockDim.x / 32){
  for (uint32_t i = warpid; i < ng - 2; i += gridDim.x * blockDim.x / 32) {
    for (uint32_t j = 0; j < ng - 2; j++) {
      uint32_t boxIdx = i * (ng - 2) + j;
      if(boxIdx>=(ng-2)*(ng-3)-1  ){return;}

      for (int temp = 0; temp < 4 * 4 * 3; temp++) {
        partial_sum[temp * BlockSizeWarp2D + threadIdx.x] = 0;
      }
      for (uint32_t TID = threadIdx.x; TID < ib[boxIdx + 1] - ib[boxIdx];
           TID += warpsize) {
        f1 = (uint32_t)floor(y[ib[boxIdx] + TID]);
        d = y[ib[boxIdx] + TID] - (coord)f1;

        v1[0] = g2(1 + d);
        v1[1] = g1(d);
        v1[2] = g1(1 - d);
        v1[3] = g2(2 - d);

        f2 = (uint32_t)floor(y[ib[boxIdx] + TID + nPts]);
        d = y[ib[boxIdx] + TID + nPts] - (coord)f2;

        v2[0] = g2(1 + d);
        v2[1] = g1(d);
        v2[2] = g1(1 - d);
        v2[3] = g2(2 - d);
        for (uint32_t iVec = 0; iVec < nVec; iVec++) {
          for (idx2 = 0; idx2 < 4; idx2++) {
            coord qv = q[nPts * iVec + ib[boxIdx] + TID] * v2[idx2];
            for (idx1 = 0; idx1 < 4; idx1++) {
              partial_sum[(iVec * 4 * 4 + idx2 * 4 + idx1) * BlockSizeWarp2D +
                          threadIdx.x] += qv * v1[idx1];
            }
          }
        }
      }

      warpReduce2V2D(partial_sum, V, f1, f2, nVec, ng, lane);
    }
  }
}

#define BlockSizeWarp2D 128
#define warpsize 32
__inline__ __device__ coord warpReduce2V2D(coord *partial_sum, coord *V,
                                           uint32_t f1, uint32_t f2,
                                           uint32_t nVec, uint32_t ng,
                                           uint32_t lane) {
  coord val;
for(uint32_t iVec=0; iVec<nVec ; iVec++){
    for (uint32_t idx2 = 0; idx2 < 4; idx2++) {
      for (uint32_t idx1 = 0; idx1 < 4; idx1++) {
        val = warp_reduce(
            partial_sum[( 4*4*iVec+dx2 * 4 + idx1) * BlockSizeWarp2D +
                        threadIdx.x]);
        if (lane == 0) {
          atomicAdd(&V[f1 + idx1 + (f2 + idx2) * ng + iVec * ng * ng], val);
        }
      }
    }
}

  return val;
}
